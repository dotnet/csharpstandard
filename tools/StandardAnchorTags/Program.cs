using Utilities;
using System.Text.Json;

namespace StandardAnchorTags;

/// <summary>
/// The entry point
/// </summary>
public class Program
{
    const string TOCHeader = "<!-- The remaining text is generated by a tool. Do not hand edit -->";
    private const string PathToStandard = "../standard/";
    private const string ReadMePath = "../standard/README.md";
    private const string FilesPath = "../standard/clauses.json";
    private const string GrammarFile = "grammar.md";

    private static Clauses? standardClauses = null!;

    /// <summary>
    /// Update section numbers, anchor tags, and the TOC
    /// </summary>
    /// <param name="owner">The GitHub owner org (for example, "dotnet")</param>
    /// <param name="repo">The GitHub repo name (for example, "csharpstandard")</param>
    /// <param name="dryrun">True for a dry run, false to update the text in all files</param>
    /// <returns>0 on success, non-zero on failure</returns>
    static async Task<int> Main(string owner, string repo, bool dryrun =false)
    {
        var logger = new StatusCheckLogger("..", "TOC and Anchor updater");
        var headSha = Environment.GetEnvironmentVariable("HEAD_SHA");
        var token = Environment.GetEnvironmentVariable("GH_TOKEN");
        using FileStream openStream = File.OpenRead(FilesPath);
        standardClauses = await JsonSerializer.DeserializeAsync<Clauses>(openStream);
        if (standardClauses is null)
        {
            Console.WriteLine("Could not read list of clauses. Exiting");
            return 1;
        }

        if (dryrun)
        {
            Console.WriteLine("Doing a dry run");
        }

        try
        {
            TocSectionNumberBuilder sectionMap = await BuildSectionMap(dryrun, logger);

            if (!dryrun)
            {
                using StreamWriter readme = await WriteUpdatedTOC(sectionMap);
            }

            await UpdateAllAnchors(dryrun, logger, sectionMap);

            if (!dryrun)
            {
                using GenerateGrammar grammarGenerator = await GenerateNewGrammar();
            }
        }
        finally
        {
            if ((token is not null) && (headSha is not null))
            {
                Console.WriteLine("Submitting check run");
                await logger.BuildCheckRunResult(token, owner, repo, headSha);
            }
        }
        return logger.Success ? 0 : 1;
    }

    private static async Task<TocSectionNumberBuilder> BuildSectionMap(bool dryrun, StatusCheckLogger logger)
    {
        Console.WriteLine("=========================== Front Matter ===================================");
        var sectionMap = new TocSectionNumberBuilder(PathToStandard, logger, dryrun);
        foreach (var file in standardClauses!.FrontMatter)
        {
            Console.WriteLine($" -- {file}");
            await sectionMap.AddFrontMatterTocEntries(file);
        }

        Console.WriteLine("================= GENERATE UPDATED SECTION NUMBERS =========================");
        Console.WriteLine("============================ Scope and Conformance ======================================");
        foreach (var file in standardClauses.ScopeAndConformance)
        {
            Console.WriteLine($" -- {file}");
            await sectionMap.AddContentsToTOC(file);

        }
        Console.WriteLine("============================ Lexical Structure ======================================");
        foreach (var file in standardClauses.LexicalStructure)
        {
            Console.WriteLine($" -- {file}");
            await sectionMap.AddContentsToTOC(file);
        }
        Console.WriteLine("============================ Main text======================================");
        foreach (var file in standardClauses.MainBody)
        {
            Console.WriteLine($" -- {file}");
            await sectionMap.AddContentsToTOC(file);
        }
        Console.WriteLine("============================ Unsafe clauses======================================");
        foreach (var file in standardClauses.UnsafeClauses)
        {
            Console.WriteLine($" -- {file}");
            await sectionMap.AddContentsToTOC(file);
        }
        Console.WriteLine("============================= Annexes ======================================");
        sectionMap.FinishMainSection();
        foreach (var file in standardClauses.Annexes)
        {
            Console.WriteLine($" -- {file}");
            await sectionMap.AddContentsToTOC(file);
        }
        return sectionMap;
    }

    private static async Task<StreamWriter> WriteUpdatedTOC(TocSectionNumberBuilder sectionMap)
    {
        Console.WriteLine("Update TOC");
        var existingReadMe = await ReadExistingReadMe();
        var readme = new StreamWriter(ReadMePath, false);
        await readme.WriteAsync(existingReadMe);
        await readme.WriteLineAsync(TOCHeader);
        await readme.WriteLineAsync();
        await readme.WriteAsync(sectionMap.Toc);
        return readme;
    }

    private static async Task UpdateAllAnchors(bool dryrun, StatusCheckLogger logger, TocSectionNumberBuilder sectionMap)
    {
        Console.WriteLine("======================= UPDATE ALL REFERENCES ==============================");
        var fixup = new ReferenceUpdateProcessor(PathToStandard, logger, sectionMap.LinkMap, dryrun);

        Console.WriteLine("=========================== Front Matter ===================================");
        foreach (var file in standardClauses!.FrontMatter)
        {
            Console.WriteLine($" -- {file}");
            await fixup.ReplaceReferences(file);
        }
        Console.WriteLine("============================ Scope and Conformance ======================================");
        foreach (var file in standardClauses.ScopeAndConformance)
        {
            Console.WriteLine($" -- {file}");
            await fixup.ReplaceReferences(file);

        }
        Console.WriteLine("============================ Lexical Structure ======================================");
        foreach (var file in standardClauses.LexicalStructure)
        {
            Console.WriteLine($" -- {file}");
            await fixup.ReplaceReferences(file);
        }
        Console.WriteLine("============================ Main text======================================");
        foreach (var file in standardClauses.MainBody)
        {
            Console.WriteLine($" -- {file}");
            await fixup.ReplaceReferences(file);

        }
        Console.WriteLine("============================ Unsafe clauses======================================");
        foreach (var file in standardClauses.UnsafeClauses)
        {
            Console.WriteLine($" -- {file}");
            await fixup.ReplaceReferences(file);

        }
        Console.WriteLine("============================= Annexes ======================================");
        foreach (var file in standardClauses.Annexes)
        {
            Console.WriteLine($" -- {file}");
            await fixup.ReplaceReferences(file);
        }
    }

    private static async Task<GenerateGrammar> GenerateNewGrammar()
    {
        Console.WriteLine("======================= READ EXISTING GRAMMAR HEADERS =======================");
        var headers = await GenerateGrammar.ReadExistingHeaders(PathToStandard, GrammarFile);

        Console.WriteLine("======================= GENERATE GRAMMAR ANNEX ==============================");
        var grammarGenerator = new GenerateGrammar(GrammarFile, PathToStandard, headers);

        Console.WriteLine("============================ Lexical Structure ======================================");

        await grammarGenerator.WriteHeader();
        foreach (var file in standardClauses!.LexicalStructure)
        {
            Console.WriteLine($" -- {file}");
            await grammarGenerator.ExtractGrammarFrom(file);
        }
        Console.WriteLine("============================ Main text======================================");

        await grammarGenerator.WriteSyntaxHeader();
        foreach (var file in standardClauses.MainBody)
        {
            Console.WriteLine($" -- {file}");
            await grammarGenerator.ExtractGrammarFrom(file);
        }
        Console.WriteLine("============================ Unsafe clauses======================================");
        await grammarGenerator.WriteUnsafeExtensionHeader();
        foreach (var file in standardClauses.UnsafeClauses)
        {
            Console.WriteLine($" -- {file}");
            await grammarGenerator.ExtractGrammarFrom(file);
        }
        await grammarGenerator.WriteGrammarFooter();
        return grammarGenerator;
    }

    private static async Task<string> ReadExistingReadMe()
    {
        using var reader = new StreamReader(ReadMePath);
        var contents = await reader.ReadToEndAsync();

        // This is the first node in the TOC, so truncate here:
        var index = contents.IndexOf(TOCHeader);

        return contents[..index];
    }
}
